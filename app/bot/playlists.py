"""Playlist generation commands using Anthropic Claude and Spotify."""

from __future__ import annotations

from aiogram import Router
from aiogram.filters import Command
from aiogram.types import Message

from ..ai.playlist_planner import (
    ClaudePlaylistPlanner,
    PlannedTrack,
    PlaylistPlannerError,
)
from ..spotify.client import SpotifyClientError
from .commands import _get_settings, _get_spotify_client, _load_tokens, _send_link_prompt
from .keyboards import build_playback_keyboard

router = Router(name="playlists")


def _playlist_name(context: str) -> str:
    trimmed = context.strip()
    base = trimmed[:64].strip() or "Custom Mix"
    return f"Mix - {base}"


def _playlist_description(context: str) -> str:
    return f"Autogenerated via Claude for: {context.strip()[:200]}"


def _find_best_uri(options: list[dict], track: PlannedTrack) -> str | None:
    target_title = track.title.lower()
    target_artist = track.artist.lower()

    for candidate in options:
        if not isinstance(candidate, dict):
            continue
        uri = candidate.get("uri")
        name = str(candidate.get("name", "")).lower()
        artists = [
            str(artist.get("name", "")).lower()
            for artist in candidate.get("artists", [])
            if isinstance(artist, dict)
        ]
        if (
            isinstance(uri, str)
            and target_title in name
            and any(target_artist in artist for artist in artists)
        ):
            return uri

    for candidate in options:
        uri = candidate.get("uri") if isinstance(candidate, dict) else None
        if isinstance(uri, str):
            return uri
    return None


def _summarize_tracks(tracks: list[PlannedTrack], limit: int = 10) -> str:
    lines = [
        f"{idx + 1}. {track.title} — {track.artist}" for idx, track in enumerate(tracks[:limit])
    ]
    if len(tracks) > limit:
        lines.append("…")
    return "\n".join(lines)


@router.message(Command("mix"))
async def handle_mix_command(message: Message) -> None:
    settings = _get_settings(message)
    tokens = await _load_tokens(message)

    if tokens is None:
        await _send_link_prompt(message, settings)
        return

    if not settings.anthropic_api_key:
        await message.answer("Anthropic API key is not configured on the server.")
        return

    if message.text is None:
        await message.answer("Provide some context, e.g. /mix dreamy evening coding")
        return

    parts = message.text.split(maxsplit=1)
    if len(parts) < 2 or not parts[1].strip():
        await message.answer("Tell me what vibe you want, for example: /mix sunset rooftop vibes")
        return

    context = parts[1].strip()
    status = await message.answer("Cooking up a playlist…")

    planner = ClaudePlaylistPlanner(api_key=settings.anthropic_api_key)
    try:
        plan = await planner.plan(context=context)
    except PlaylistPlannerError as exc:
        await status.edit_text(f"Claude couldn't build a playlist: {exc}")
        return

    spotify = _get_spotify_client(message)
    if message.from_user is None:
        await status.edit_text("I couldn't detect your Telegram account.")
        return

    found_tracks: list[tuple[PlannedTrack, str]] = []
    missing_tracks: list[PlannedTrack] = []

    for planned in plan.tracks:
        query = f"{planned.title} {planned.artist}"
        try:
            results = await spotify.search_track(message.from_user.id, query=query, limit=5)
        except SpotifyClientError as exc:
            await status.edit_text(f"Spotify search failed: {exc}")
            return
        uri = _find_best_uri(results, planned) if results else None
        if uri is None:
            missing_tracks.append(planned)
        else:
            found_tracks.append((planned, uri))

    if not found_tracks:
        await status.edit_text("Couldn't match any of the suggested songs on Spotify.")
        return

    playlist_name = _playlist_name(context)
    playlist_description = _playlist_description(context)

    try:
        playlist = await spotify.create_playlist(
            message.from_user.id,
            name=playlist_name,
            description=playlist_description,
            public=False,
        )
    except SpotifyClientError as exc:
        await status.edit_text(f"Failed to create playlist: {exc}")
        return

    playlist_id = playlist.get("id") if isinstance(playlist, dict) else None
    playlist_url = None
    if isinstance(playlist, dict):
        external = playlist.get("external_urls")
        if isinstance(external, dict):
            playlist_url = external.get("spotify")

    if not isinstance(playlist_id, str):
        await status.edit_text("Spotify did not return a playlist identifier.")
        return

    try:
        await spotify.add_tracks(
            message.from_user.id,
            playlist_id=playlist_id,
            track_uris=[uri for _, uri in found_tracks],
        )
    except SpotifyClientError as exc:
        await status.edit_text(f"Unable to add tracks: {exc}")
        return

    summary = _summarize_tracks([track for track, _ in found_tracks])
    message_lines = [
        "✅ Playlist created!",
        f"Name: <b>{playlist_name}</b>",
    ]
    if playlist_url:
        message_lines.append(f"Link: <a href='{playlist_url}'>{playlist_url}</a>")
    message_lines.append("\nTop picks:\n" + summary)

    if missing_tracks:
        missed_summary = ", ".join(
            f"{track.title} — {track.artist}" for track in missing_tracks[:5]
        )
        message_lines.append(f"\nCouldn't find: {missed_summary}")

    await status.edit_text(
        "\n".join(message_lines),
        parse_mode="HTML",
        disable_web_page_preview=False,
        reply_markup=build_playback_keyboard(),
    )


__all__ = ["handle_mix_command", "router"]
